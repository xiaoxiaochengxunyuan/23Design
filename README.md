# 23Design

23种设计模式学习
## 简单工厂
*  简单工厂本质：
>选择实现，具体实现都是由实现类实现，而不是在简单工厂里面实现，在简单工厂里面只提供选择相应的实现，从而使得客户端和实现之间解耦。这样依赖，实现类变化了，就不用变动客户端，这个变化就会被简单工厂吸收和屏蔽掉。

* 优点：
>封装:简单工厂原理很简单，但是对只暴露一个工厂类，友好的实现了组件的封装，让组件外部能真正面向接口编程
>解耦：实现了客户端和具体实现类的解耦

* 缺点
>复杂度：可能增加客户端的复杂度,必须要客户端理解各个参数代表的具体功能和含义，增加客户端的难道度，暴露部门客户端部分实现。可以采用配置、容器等方式实现
>不方便扩展子工程：私有化简单工厂的构造方法，使用静态方法来创建接口,也就不能通过写简单工厂类的自雷来改变创建接口的方法的行为。

* 何时选用简单工厂
>希望完全封装隔离具体的实现，只让客户端通过工厂获取相应的接口，而无需关心具体的实现。
>把对外创建独享的职责集中管理和控制，可以选用简单工厂，一个简单工厂可以创建很多的、不相关的对象，可以把对外创建对象的职责集中到一个简单工厂来。

## 外观模式
*  外观模式本质：
>封装交互，简化调用 封装了子系统外部和子系统内部多个模块的交互过程，从而简化了外部的调用。通过外观，子系统为外部提供一些高层的接口，以方便它们的使用。

* 优点：
>松散耦合:外观模式松散了客户端与子系统的耦合关系，让子系统内部的模块能更容易扩展和维护。
>简单易用:外观模式让子系统更加易用，客户端不在需要了解子系统内部的实现，也不需要跟众多子系统内部的模块进行交互，只需要跟外观交互就可以了，相当于外观类为外部客户端使用子系统提供了一站式服务。
>更好地划分访问的层次:通过合理使用Facade，可以帮助我们更好地划分访问层次。有些方法是对系统外的，有些方法是系统内部使用的。把需要暴露给外部的功能集中到外观中，这样即方便客户端使用，也很好地隐藏了内部的细节。

* 缺点
>复杂度：过多的或者是不太合理的Facade也容易让人迷惑。到底是调用Facade好呢，还是直接调用模块好。

* 何时选用外观模式
>如果你希望为一个复杂的子系统提供一个简单接口的时候，可以考虑使用外观模式。使用外观对象来实现大部分顾客需要的功能，从而简化客户的使用。
>如果想要让客户程序和抽象类的实现部分松散耦合，可以考虑使用外观模式，使用外观对象来将这个子系统与他的客户分离开来，从而提高子系统的独立性和可移植性
>如果构建多层结构的系统，可以考虑使用外观模式，使用外观对象作为每层的入口，这样可以简化层间调用，也可以松散层次之间的依赖关系。

*PS
>感觉有点想MVC模式，一个是系统架构层次，一个代码设计层次。
